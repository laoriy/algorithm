# 链表

1. 链表中的每个节点至少包含两个部分：数据域+ 指针域
2. 链表中的每个节点，通过指针域的值，形成一个线性的结构
3. 查找几点 O(n)，插入节点 O(1)， 删除节点 O(1)
4. 不合适快速的定位数据，适合动态的插入和删除数据的应用场景

### 链表实现：

-   一个节点通过 next 属性指向下个链表节点
-   两个数组，data 记录数据，next 记录在 data 中的位置，next[index]指向 p,data[p] = val

### 链表的应用场景

1. 操作系统内的动态内存分配
2. LRU 缓存淘汰算法

### 经典面试题

#### 链表

141. 链表是否有环：


    - 只需要遍历这个链表，在遍历的过程中记录我们遍历过的节点；如果遇到next节点为null的节点，说明没有环。如果遇到我们以前遍历过的节点，说明有环。
    - 快慢指针，两个指针一快一慢，如果快的到null了，则没有环。反之，如果有环快的一定会追上慢的。

142. 环形节点的起始位置：


    - 通过快慢指针判断有环，指针相遇点为p
    - p 距离环起点位置和 head 距离环起点位置的距离一样，只要将其中一个指针从head开始，一个从p开始，继续通过next找到的相遇点即为环的起点；

202. 快乐数 -- 唯一指向性

##### 链表反转

206. 链表反转


    - 将pre指向反转后的链表的头节点，将current指向未反转的链表的头节点，将next指向未反节点的次节点，遍历。
    - 递归回溯，进行链表反转，将head.next 作为下一次reverseList的head参数传入进行递归，并记录为tail。然后进行head.next 执行tail.next, tail.next 指向head进行反转。

92. 链表反转（m -> n）

    -   基于 reveseN（见 index.js）函数
    -   首先将 p 指向待反转起始位置的前一位，防止从第一个开始位置开始的时候，没有前一位，所以在链表开头价一个虚拟节点。
    -   然后将 p.next 指向 reverseN(p.next, n - m + 1)后的新链表

93. K 个一组反转链表

    -   判断链表的节点数是不是够 K 个，如果够的话直接调用 reveseN 进行反转，否则返回 head
    -   同样加一个虚拟头节点 p，q 指向 head.next,然后将剩余节点的前 n 个节点进行反转，反转后 q 的位置就变成下一次反转的 p,q 再置为 p.next。

94. 旋转链表--右移旋转 k 位
    -   找到最后一个链表节点 ，并且指向头位置，并记录长度 len。
    -   然后将指针往后移动 len - k 后的节点的 next 置为空（链表断掉）

##### 删除链表

19. 删除链表的倒数第 n 个节点

    -   加一个虚拟头节点，指针 p 指向它（head）。
    -   指针 q 指向 p 后第 n 个节点
    -   一起往后移动指针 p 和 q，当 q 为空的时候，p 位于将要删除的节点的前一个节点，然后将 p.next 指向 p.next.next 绕过要删除的节点

20. 删除排序链表中的重复元素

-   让 p 等于 head,当 p.val === p.next.val 将 p.next 指向 p.next.next 否则，将 p 移动到 p.next

82. 删除排序链表中的重复元素 --只要出现过重复就全部删掉

-   由于头节点可能被删除，因此加一个虚拟节点 ret
-   变量 p 等于 ret 如果 p.next && p.next.next 的时候进行遍历
-   如果 p.next 的 val 等于 p.next.next.val 时，将该值记录为 x、如果 p.next && p.next.val === x 时进行遍历，并将 p.next 指向 p.next.next（指针移动），这次遍历结束时，p.next.val 肯定是一个新值
-   反之，p = p.next。此时 p.next 已经是一个不重复的新值。进入下一次外层遍历。

### 复习

86. 分隔链表 小于 x 的放左边

-   构造两个链表头，分别为 small 和 large。然后变量 smallHead 指向 small , 变量 largeHead 指向 small。
-   设置指针 p 遍历原链表，小于 x 的让 smallHead.next 指向 p,此时相当于 small.next 指向 p，然后 smallHead = p。大于 x 的逻辑一样;
-   最终将 largeHead.next 指向 null , smallHead.next = large.next 最后返回 small.nex

138. 复制带随机指针的链表
- 每个节点复制一个然后连接到原节点的后面，成为一个链表。这时候复制节点的random节点即为源节点的random节点的next。
- 再讲链表拆成两个独立的链表