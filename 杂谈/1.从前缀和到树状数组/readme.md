## 再看前缀和数组

- 初始化：O(n) 时间复杂度，顺序扫描原数组即可
- 查询区间和：O(1) 时间复杂度，S[j] - S[i] 即为 原数组 i 到 j 之和
- 单点修改：O(n) 时间复杂度,需要修改 S[i] --> S[n] 的所有元素

擅长区间和查询，不擅长单点修改，因为 S[i] 的值 与原数组中 i 之前所有项都有关系

弱化这种关系，即可加快单点修改的速度，但也会丧失部分查询效率

## 树状数组(Binary Indexed Tree)

### lowbit 函数

lowbit(i) 代表 i 的二进制表示中最右边的 1 的位权

```js
    lowbit(8) = (1000) = 8
    lowbit(6) = (0110) = 2
    lowbit(12) = (01100) = 4
    lowbit(7) = (0111) = 1

    function lowbit(i) {
        return i & (-i);
    }
```

### 改进前缀和

约定 C[i] = lowbit(i)，代表前 lowbit(i) 项的和，例如：

    C[8] 代表从 8 开始前 8（lowbit(8)） 项的和

    C[7] 代表从 7 开始前 1（lowbit(7)）项的和

    C[6] 代表从 6 开始前 2（lowbit(6)）项的和

    C[5] 代表从 5 开始前 1（lowbit(5)）项的和

    C[4] 代表从 4 开始前 4（lowbit(4)）项的和

    C[3] 代表从 3 开始前 3（lowbit(3)）项的和

    C[2] 代表从 2 开始前 2（lowbit(2)）项的和

    C[1] 代表从 1 开始前 1（lowbit(1)）项的和

如下图：更新效率变高
![](../images/树状数组.jfif)

1. 扁平的树状结构使得单点修改的效率得到提升。修改了 a[1]只需要修改 c[1],c[2],c[4],c[8]，而不需要修改 c[3],c[5]c[6],c[7]
2. 分段求和使得查询的效率降低：查询前 7 个元素的和=c[4] + c[6] + c[7]

### 基本操作

- 前缀和查询：前缀和查询： S[i] = S[i - lowbit(i)] + C[i] （向前统计）

- 单点修改：A[j]发生改变时，当修改完 C[j]，下一个应该修改的是 C[j+lowbit[j]] （向后更新）
