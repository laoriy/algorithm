# 堆与优先队列

### 堆基础知识：
可以认为堆是基于二叉树--完全二叉树的一种数据结构
```js
        1
      /   \
     2     3
    / \   / 
   4   5 6 
```
1. 完全二叉树特点：
    1. 编号为i的子节点（跟节点为1），左孩子编号为`2*i`,右孩子编号为`2*i+1`
    2. 可以用连续的存储空间存储（数组）：[1,2,3,4,5,6]

2. 大顶堆：任意一个三元组，父节点比两个子节点都大，跟值最大。
3. 小顶堆：任意一个三元组，父节点两个比子节点都小，跟值最小。
4. 堆（尾部）插入元素。向上调整：新插入的元素与父节点相比，如果比父节点大，则与父节点调换位置，依次类推，直至满足大顶堆结构性质。
```
       12                 12            12           13 
      /  \               /  \          /  \         /  \                  
     11  10  --插13->   11  10  --->  13  10  ---> 12  10              
    /                  / \           / \          / \             
   6                  6   13        6   11       6   11         
```

5. 堆（头部）弹出元素：头部弹出后，将堆最后一个元素放在头的位置。向下调整：该元素为父节点的三元组中最大的值（左右孩子）与其交换，依次类推。

```
       12                 4            11           11 
      /  \               / \          /  \         /  \                  
     11  10  --弹12->   11  10  ---> 4   10  ---> 6   10              
    / \   \            /  \         / \          / \             
   6   5   4          6    5       6   5        4   5         
```
6. 堆排序：
    1. 将堆顶元素与队尾元素交换
    2. 将此操作看成是堆顶元素弹出操作
    3. 按照头部弹出以后的策略调整堆。


7. 堆存储成数组的形式，尾部入头部出，就像一个队列，并且每次出的都是元素集合中最大的值，即为优先队列。堆是优先队列的一种实现方式。


### 堆的基本实现
见index.js代码

### 堆适合处理什么问题
- 一句话理解堆：堆适合维护 --> 集合最值

### 经典面试题--堆的基础应用
剑指 Offer 40. 最小的k个数
- 可以通过大顶堆实现，将每个数据添加到大顶堆里面，然后如果数量此时大于k，则pop，根据大顶堆的特点，最后留下的k个一定都是最小的。
1046. 最后一块石头的重量
703. 数据流中的第 K 大元素 --排序的效率
373. 查找和最小的 K 对数字
692. 前K个高频单词

295. 数据流的中位数
    1. 从中间位置分开看，前面是个大顶堆，后面是个小顶堆--- 对顶堆
    2. 插入元素时和小顶堆 堆顶元素比较，如果大于小顶堆堆顶，插入小顶堆（右边），反之插入大顶堆（左边）
    3. 通过比较两个堆长度，如果前面多与后面两个，往后面塞,如果后面多与前面两个，往前面塞，分别处理的都是顶堆元素
264. 丑数 II
    1. 同第17.09. 第k个数类似，新的丑数都是基于已有的丑数来计算的，搞三个指针，初始都指向为0，在已有丑数（初始为1）里面找出一个最小值分别*2，*3，*5得出新的一系列丑数，然后将最小值放入丑数数组，并移动最小值对应的指针+1。
    2. 小顶堆。最小值就在最顶端，这个最小值乘以大于等于它的最大素因子，如最大素因子为5 ，则可以乘5；如最大素因子为3 ，则可以乘3,5；如最大素因子为2 ，则可以乘2,3,5，然后将结果放入堆中。

313. 超级丑数

```js
function nthSuperUglyNumber(n: number, primes: number[]): number {
    const pins:number[] = []
    const ans = [1]

    while(ans.length < n){
        let min
        for(let i = 0;i < primes.length;i++){ // 计算最小值
            pins[i] = pins[i] || 0
            let val = ans[pins[i]] * (primes[i])
            min = min > val ? val : min ?? val;
        }

       for(let i = 0;i < primes.length;i++){ // 移动最小值对应的指针+1的位置，也就是这次的min位置，作为下一次的丑数基础。
            let val = ans[pins[i]] *(primes[i])
            if(min === val){
                pins[i]++
            }
        }
        ans.push(min)
    }
    return ans[n - 1]
}; 
```

1753. 移除石子的最大得分

- 将所有石子尽可能都清空，即为最大得分。
```js
function maximumScore(a: number, b: number, c: number): number {
    const d = [a,b,c]
    d.sort((a,b)=>a-b);
    [a,b,c] = d;
    let ans = 0
    // 排好序的a<=b<=c
    // step1. 用a 的一部分尽量去消掉b和c的差值
    let cnt1 = Math.min(c-b,a)
    a-= cnt1
    c-= cnt1
    ans = cnt1

    // step2. 如果a大于0，则b = c,反之b<=c
    if(a > 0){
        if(a % 2 !== 0) a-- // a偶数化
        ans = ans + a + (b - a / 2) //a清除完用a次。剩余的b为b - a / 2次
    } else {
        ans += b
    }
    return ans
};

```
1801. 积压订单中的订单总数
- 两个堆，一个大顶堆，一个小顶堆，根据订单的类型，进行和某个堆的堆顶元素进行对比，出入栈操作。


