## 搜索的核心概念

问题求解树 -- 思维逻辑中的结构

1. 什么是深搜和广搜？
   - 对于问题求解树的两种不同的遍历方式
2. 什么是搜索剪枝和优化？
   - 排除问题求解树中的某些子树的遍历过程
3. 设计搜索算法的核心关键点是什么？
   - 就是设计在问题求解树中的状态

## DFS（Depth First Search）深度优先遍历

- 993. 二叉树的堂兄弟节点： 深度遍历分别得出 x 的深度+父节点 和 y 的深度+父节点，进行比较

通常以递归的方式实现

- 130. 被围绕的区域，[代码](./dfs/solve.js)
- 494. 目标和，[代码](./dfs/findTargetSumWays.js): 注意使用 map 缓存 部分计算结果，提高效率
- 473. 火柴拼正方形，[代码](./dfs/makesquare.js): 从大到小依次放入四个桶中，
- 39. 组合总和，[代码](./dfs/combinationSum.js): 
![images](./images/combinationSum.png)

## BFS（Breadth First Search）广度优先遍历

通过队列，层序遍历

- 993. 二叉树的堂兄弟节点：广度遍历记录父节点和深度

- 542. 01 矩阵，[代码](updateMatrix.js)

  - 结果数组默认都没有到过，每个值都为-1。

  - 将所有为 0 的加入队列，然后这些为 0 的上下左右，凡是没有到过的相当于是只需一步就从 0 ---> 1，再将这些 1 加入队列
  - 一直遍历直到队列为空。

  通过逆向思维，元素通过几步能到达 0 ，即 0 通过几步能到达对应元素；

  然后分解，0 通过一步能到达的为 1,1 通过一步能到达的为 2，以此类推

- 1091. 二进制矩阵中的最短路径，[代码](./shortestPathBinaryMatrix.js)

  其实和上面一题类似，从[0,0]出发，依次寻找八个方向，将没有走过的位置合适的数据加入队列，直到最后一个。

- LCR 130. 衣橱整理，[代码](./wardrobeFinishing.js)

  和上面雷同，需要一个二维数组记录有没有整理过，然后以此从左上角开始整理，没整理过的加入队列即可。

- 752. 打开转盘锁，[代码](./openLock.js)，[代码自我版本](./openLock_ugly.js)
       从 0000 开始 每走一步将 可能的合法的结果加入队列， 下次将这些数据一次拿出来生成新的可能，
