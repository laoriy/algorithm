/**
 * 整数数组 sockets 记录了一个袜子礼盒的颜色分布情况，其中 sockets[i] 表示该袜子的颜色编号。礼盒中除了一款撞色搭配的袜子，每种颜色的袜子均有两只。请设计一个程序，在时间复杂度 O(n)，空间复杂度O(1) 内找到这双撞色搭配袜子的两个颜色编号。

 

示例 1：

输入：sockets = [4, 5, 2, 4, 6, 6]
输出：[2,5] 或 [5,2]
示例 2：

输入：sockets = [1, 2, 4, 1, 4, 3, 12, 3]
输出：[2,12] 或 [12,2]
 

提示：

2 <= sockets.length <= 10000
 */


/**
 * @param {number[]} sockets
 * @return {number[]}
 */
var sockCollocation = function (sockets) {
    // ========== 第一步：对所有数字进行异或操作 ==========
    // 
    // 异或操作（^）的特点：
    // - 相同数字异或结果为 0：a ^ a = 0
    // - 任何数字与 0 异或结果不变：a ^ 0 = a
    // - 异或满足交换律和结合律：a ^ b ^ c = (a ^ b) ^ c
    //
    // 因为除了两个数字外，其他数字都出现两次
    // 所以所有数字异或后，出现两次的数字会相互抵消变成 0
    // 最终 ret 的值 = m ^ n（两个只出现一次的数字的异或结果）

    let ret = 0  // 初始化结果为 0

    // 遍历数组，对每个数字进行异或操作
    for (socket of sockets) {
        // 每次异或操作：ret = ret ^ socket
        // 例如：ret = 0 ^ 1 = 1, 然后 ret = 1 ^ 2 = 3, ...
        // 最终 ret 等于所有出现一次的数字的异或结果（即 m ^ n）
        ret = socket ^ ret
    }

    // ========== 第二步：找到 ret 中第一个为 1 的位 ==========
    //
    // 因为 ret = m ^ n，且 m ≠ n，所以 ret 至少有一位是 1
    // 这个为 1 的位说明：m 和 n 在这一位上不同（一个是 0，一个是 1）
    // 我们可以利用这个差异来将数组分成两组

    let flag = 1  // 从最低位（最右边）开始，flag = 1 表示二进制 0001

    // 循环查找：找到 ret 中第一个为 1 的位
    // (flag & ret) === 0 表示当前 flag 对应的位在 ret 中是 0
    // 如果当前位是 0，就把 flag 左移一位（相当于检查下一位）
    // 例如：如果 ret = 6（二进制 0110），flag 会从 1(0001) -> 2(0010) -> 4(0100)
    // 当 flag = 2(0010) 时，2 & 6 = 2 ≠ 0，循环结束，flag = 2
    while ((flag & ret) === 0) {
        // flag <<= 1 表示将 flag 左移一位（相当于乘以 2）
        // 例如：1(0001) -> 2(0010) -> 4(0100) -> 8(1000)
        flag <<= 1
    }
    // 循环结束后，flag 就是 ret 中第一个为 1 的位
    // 例如：如果 ret = 6（二进制 0110），flag = 2（二进制 0010）

    // ========== 第三步：根据 flag 位将数组分成两组，分别异或 ==========
    //
    // 因为 flag 对应的位在 m 和 n 中不同（一个是 0，一个是 1）
    // 所以我们可以根据这个位将数组分成两组：
    // - 第一组：该位为 1 的数字（包括 m 或 n 中的一个）
    // - 第二组：该位为 0 的数字（包括 m 或 n 中的另一个）
    //
    // 这样，每组中除了一个只出现一次的数字外，其他数字都成对出现
    // 对每组分别进行异或操作，就能得到 m 和 n

    let m = 0, n = 0;  // 初始化两个结果变量

    // 遍历数组，根据 flag 位将数字分组
    for (socket of sockets) {
        // socket & flag 检查 socket 在 flag 对应的位上是否为 1
        // 如果为 1，说明这个数字应该分到第一组
        if (socket & flag) {
            // 对第一组的数字进行异或操作
            // 因为除了 m（或 n）外，其他数字都成对出现，会相互抵消
            // 最终 m 的值就是第一组中只出现一次的那个数字
            m ^= socket  // 等价于 m = m ^ socket
        } else {
            // 如果为 0，说明这个数字应该分到第二组
            // 对第二组的数字进行异或操作
            // 最终 n 的值就是第二组中只出现一次的那个数字
            n ^= socket  // 等价于 n = n ^ socket
        }
    }

    // 返回找到的两个只出现一次的数字
    return [m, n]
};

console.log(sockCollocation([4, 5, 2, 4, 6, 6]))
console.log(sockCollocation([1, 2, 4, 1, 4, 3, 12, 3]))